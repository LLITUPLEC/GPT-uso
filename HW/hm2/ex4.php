4. Объясните назначение и применение магических методов __get, __set, __isset, __unset, __call и __callStatic.
Когда, как и почему их стоит использовать (или нет)?

Все магические методы ДОЛЖНЫ быть объявлены как public.

Магический метод __get() будет отлавливать обращения к любым не публичным свойствам.
Метод __get() приминает имя свойства, к которому вы обращаетесь, в качестве аргумента.
<?php
public function __get($property)
{
  if (property_exists($this, $property)) {
    return $this->$property;
  }
}
?>
В приведенном выше примере сначала проверяется существование свойства в объекте и если оно существует, то возвращается его значение.

Как и в примерах выше — мы не должны вызывать этот метод напрямую, PHP будет вызывать его каждый раз,
при попытке получения доступа к не публичным свойствам класса.

В обратной ситуации — если мы попытаемся установить значение свойства, которое не является публичным — мы получим ошибку.
И опять же, в PHP есть свой метод, который будет вызван при попытке установить в не публичное поле какое-либо значение.
Данный метод принимает 2 параметра в качестве аргументов — свойство, в которое хотели записать значение, и само значение.

<?php
public function __set($property, $value)
{
  if (property_exists($this, $property)) {
    $this->$property = $value;
  }
}

$tweet->text = 'Setting up my twttr';
echo $tweet->text; // 'Setting up my twttr'
?>

В приведенных выше примерах показано как можно получить или установить значения свойств,
не имеющих модификатор доступа public. Однако работа с данными магическими методами не всегда будет лучшей идеей.
Гораздо лучше иметь множество методов для получения и записи свойств, так как в этом случае они формируют
определенный API и это означает, что при изменении способа хранения или обработки наш код не будет сломан.




функцию isset(), обычно применяют при работе с массивами. Мы так же можем использовать эту функцию,
для того чтобы понять — задано свойство в обьекте или нет. Мы сможем определить магический метод __isset(),
для того чтобы можно проверять не только общедоступные свойства, но и другие.
<?php
public function  __isset($property)
{
  return isset($this->$property);
}

isset($tweet->text); // true
?>
Как видно выше, __isset() метод отслеживает вызов функции на проверку существования и получает в качестве
аргумента — название свойства. В свою очередь, в методе мы можем использовать функцию isset(), для проверки существования.

Очистка переменной
По аналогии с функцией isset(), функция unset() обычно используется при работе с массивами.
Опять же, мы можем использовать функцию unset() для того чтобы очистить значение не публичного свойства.
Чтобы применить данный метод на не публичные свойства, нам понадобиться метод __unset(), который будет отслеживать
попытки очистить не публичный свойства класса.
<?php
public function __unset($property)
{
  unset($this->$property);
}
?>



Магический метод __call(), будет перехватывать все попытки вызовов методов, не являющихся публичными.
Например, у нас может быть массив данных, которые мы хотим изменить:
<?php
class Tweet {
  protected $id;
  protected $text;
  protected $meta;

  public function __construct($id, $text, array $meta)
  {
    $this->id = $id;
    $this->text = $text;
    $this->meta = $meta;
  }

  protected function retweet()
  {
    $this->meta['retweets']++;
  }

  protected function favourite()
  {
    $this->meta['favourites']++;
  }

  public function __get($property)
  {
    var_dump($this->$property);
  }

  public function __call($method, $parameters)
  {
    if (in_array($method, array('retweet', 'favourite')))
    {
      return call_user_func_array(array($this, $method), $parameters);
    }
  }
}

$tweet = new Tweet(123, 'hello world', array('retweets' => 23, 'favourites' => 17));

$tweet->retweet();
$tweet->meta; // array(2) { ["retweets"]=> int(24) ["favourites"]=> int(17) }
?>
Если мы пытаетемся вызвать статический метод, мы можем так же воспользоваться __callStatic() магическим методом.
Главное помнить, что работает он лишь при вызове статичных методов.


