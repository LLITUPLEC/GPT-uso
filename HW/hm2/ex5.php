5. Опишите несколько структур данных из стандартной библиотеки PHP (SPL). Приведите примеры использования.


    SplStack
Наследник DLL, реализующий структуру стека. Стек – это абстрактный тип данных, представляющий список элементов, организованных по принципу LIFO.
<?php
$stack = new SplStack();

// Добавляем элемент в стек
$stack->push('1');
$stack->push('2');
$stack->push('3');

echo $stack->count();     // 3
echo "\n";
echo $stack->top();         // 3
echo "\n";
echo $stack->bottom();   // 1
echo "\n";
echo $stack->serialize(); // i:6;:s:1:"1";:s:1:"2";:s:1:"3";
echo "\n";

// Извлекаем элементы из стека
echo $stack->pop();       // 3
echo "\n";
echo $stack->pop();       // 2
echo "\n";
echo $stack->pop();       // 1
echo "\n";
?>


    SplQueue
Структура для создания очереди.
Очередь – это абстрактный тип данных с порядком доступа к элементам по принципу FIFO.
Добавление элемента (принято обозначать словом enqueue – «поставить в очередь») возможно только в конец очереди,
выборка – только из начала (dequeue – «убрать из очереди»), при этом выбранный элемент из очереди удаляется.
По сути – то же самое, что стек, только по принципу FIFO.

<?php
$queue = new SplQueue();

$queue->setIteratorMode(SplQueue::IT_MODE_DELETE);

$queue->enqueue('one');
$queue->enqueue('two');
$queue->enqueue('qwerty');

$queue->dequeue();
$queue->dequeue();

echo $queue->top(); // qwerty
?>



    SplHeap
Это реализация древовидной структуры Heap («куча»), в которой любой узел должен быть больше своих потомков или равен им.
Для узлов применяется пользовательский метод сравнения, являющийся единым для всей структуры.
SplHeap сам по себе – только абстрактная реализация Heap.

<?php
$heap->insert('111');
$heap->insert('666');
$heap->insert('777');

echo $heap->extract(); // 777
echo "\n";
echo $heap->extract(); // 666
echo "\n";
echo $heap->extract(); // 111
echo "\n";

echo "SplMinHeap \n";
$heap = new SplMinHeap();
$heap->insert('111');
$heap->insert('666');
$heap->insert('777');

echo $heap->extract(); // 111
echo "\n";
echo $heap->extract(); // 666
echo "\n";
echo $heap->extract(); // 777
echo "\n";
?>



    SplPriorityQueue
Класс, предоставляющий возможности очереди с приоритетами. Базируется на куче max heap,
что позволяет автоматически сортировать узлы по приоритетам. Алгоритм доступа к данным – FIFO, как и для обычной очереди.
<?php
$queue = new SplPriorityQueue();
$queue->setExtractFlags(SplPriorityQueue::EXTR_DATA); // Получаем только значения элементов

$queue->insert('Q', 1);
$queue->insert('W', 2);
$queue->insert('E', 3);
$queue->insert('R', 4);
$queue->insert('T', 5);
$queue->insert('Y', 6);

$queue->top();
while($queue->valid())
{
    echo $queue->current();
    $queue->next();
}
// YTREWQ
?>

    SplFixedArray
Это класс для реализации массива с фиксированным количеством элементов. SplFixedArray хранит в непрерывном виде данные,
которые доступны только через их числовые индексы. Этот вид массива работает быстрее, чем стандартные,
создаваемые через команду array. Но есть ряд ограничений:
    - в качестве ключей могут быть только целые числа > 0;
    - длина может быть изменена, но это затратная операция.
Уточним, как работают привычные массивы в PHP. В движке PHP массив, создаваемый при помощи команды array,
является не совсем массивом, а упорядоченным списком с картой ключей (map). В результате имеем гибкую структуру данных,
но принципы ее работы не всегда оптимальны.
В языке С, на котором написан сам PHP, не существует ассоциативных массивов и массивов без размеров. При создании
массива в C необходимо указать его размер, чтобы система выделила для него строго определенное место в памяти.
В момент, когда добавляется массив через array, PHP создает его все же с определенным размером. По мере заполнения
значениями достигается лимит. Именно в этот момент неявно создается новый массив размером вдвое больше.
При этом все элементы будут скопированы в него, после чего старый массив уничтожается.

